# Design Patterns Repository

This repository contains various **Design Patterns** and their definitions. Each design pattern has its corresponding folder with detailed examples. The patterns are categorized based on their types, such as Creational, Structural, and Behavioral patterns.

## Overview

Design patterns are reusable solutions to common problems in software design. They help to solve design challenges and make your code more flexible and easier to maintain. This repository contains examples of each pattern for easy learning and implementation.

---

## Table of Contents

-  [Creational Patterns](#creational-patterns)

   -  [Singleton](#singleton)
   -  [Factory Method](#factory-method)
   -  [Abstract Factory](#abstract-factory)
   -  [Builder](#builder)
   -  [Prototype](#prototype)

-  [Structural Patterns](#structural-patterns)

   -  [Adapter](#adapter)
   -  [Bridge](#bridge)
   -  [Composite](#composite)
   -  [Decorator](#decorator)

-  [Behavioral Patterns](#behavioral-patterns)
   -  [Observer](#observer)
   -  [Strategy](#strategy)
   -  [Command](#command)
   -  [State](#state)
   -  [Iterator](#iterator)

---

## Creational Patterns

### Singleton

**Definition**: The **Singleton** pattern ensures that a class has only one instance and provides a global point of access to it.

**Example**: Find the example in the folder [**creational/singleton**](creational/singleton.ts).

---

### Factory Method

**Definition**: The **Factory Method** defines an interface for creating objects, but it lets subclasses decide which class to instantiate.

**Example**: Find the example in the folder [**creational/factory-method**](creational/factory-method.ts).

---

### Abstract Factory

**Definition**: The **Abstract Factory** provides an interface for creating families of related or dependent objects without specifying their concrete classes.

**Example**: Find the example in the folder [**creational/abstract-factory**](creational/abstract-factory.ts).

---

### Builder

**Definition**: The **Builder** pattern separates the construction of a complex object from its representation, allowing for the creation of objects step by step.

**Example**: Find the example in the folder [**creational/builder**](creational/builder.ts).

---

### Prototype

**Definition**: The **Prototype** pattern creates new objects by copying an existing object (the prototype).

**Example**: Find the example in the folder [**creational/prototype**](creational/prototype.ts).

---

## Structural Patterns

### Adapter

**Definition**: The **Adapter** pattern allows incompatible interfaces to work together by providing a wrapper around one of the interfaces.

**Example**: Find the example in the folder [**structural/adapter**](structural/adapter.ts).

---

### Bridge

**Definition**: The **Bridge** pattern decouples an abstraction from its implementation, allowing both to vary independently.

**Example**: Find the example in the folder [**structural/bridge**](structural/bridge.ts).

---

### Composite

**Definition**: The **Composite** pattern allows you to treat individual objects and compositions of objects uniformly. It is especially useful in recursive structures like trees or file systems.

**Example**: Find the example in the folder [**structural/composite**](structural/composite.ts).

---

### Decorator

**Definition**: The **Decorator** pattern allows you to add functionality to an object at runtime, without modifying its structure.

**Example**: Find the example in the folder [**structural/decorator**](structural/decorator.ts).

---

## Behavioral Patterns

### Observer

**Definition**: The **Observer** pattern defines a one-to-many dependency between objects, where one object (the subject) notifies multiple other objects (observers) of any state changes.

**Example**: Find the example in the folder [**behavioral/observer**](behavioral/observer.ts).

---

### Strategy

**Definition**: The **Strategy** pattern defines a family of algorithms and makes them interchangeable. It allows you to select the algorithm to use at runtime.

**Example**: Find the example in the folder [**behavioral/strategy**](behavioral/strategy.ts).

---

### Command

**Definition**: The **Command** pattern encapsulates a request as an object, allowing you to parameterize clients with queues, requests, and operations.

**Example**: Find the example in the folder [**behavioral/command**](behavioral/command.ts).

---

### State

**Definition**: The **State** pattern allows an object to alter its behavior when its internal state changes.

**Example**: Find the example in the folder [**behavioral/state**](behavioral/state.ts).

---

### Iterator

**Definition**: The **Iterator** pattern provides a way to access the elements of a collection sequentially, without exposing the underlying representation.

**Example**: Find the example in the folder [**behavioral/iterator**](behavioral/iterator.ts).

---

## Contributions

Feel free to contribute to this repository! Fork it and create a pull request to add new patterns, improve existing examples, or make suggestions.

---

Happy coding! ðŸš€
